"; -*- Mode: Lisp -*-"
(SYSTEM:INIT-FASL :VERSION 42)
(SETQ SYSTEM:*SOURCE* #P"/Volumes/vibhu/quicklisp/dists/quicklisp/software/lparallel-20131111-git/packages.lisp")


(SYSTEM::%DEFPACKAGE "LPARALLEL.UTIL" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL") (#2#  '#1# ) '#1#  '("WITH-GENSYMS" "DEFMACRO/ONCE" "UNSPLICE" "SYMBOLICATE" 
"WITH-PARSED-BODY" "WHILE" "UNTIL" "REPEAT" "WHEN-LET" "DOSEQUENCE" "ALIAS-FUNCTION" 
"ALIAS-MACRO" "UNWIND-PROTECT/EXT" "IMPORT-NOW" "DEFUN/INLINE" "DEFUN/TYPE" "DEFUN/TYPE/INLINE" 
"DEFSLOTS" "DEFPAIR" "INTERACT" "ENSURE-FUNCTION" "TO-BOOLEAN" "INDEX" "*NORMAL-OPTIMIZE*" 
"*FULL-OPTIMIZE*") '#1#  '"(private) Miscellaneous utilities.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.THREAD-UTIL" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL") (#2#  '#1# ) '#1#  '("WITH-THREAD" "WITH-LOCK-PREDICATE/WAIT" 
"WITH-LOCK-PREDICATE/NO-WAIT" "CONDITION-NOTIFY" "CAS" "MAKE-SPIN-LOCK" "WITH-SPIN-LOCK-HELD" 
"MAKE-LOCK" "MAKE-CONDITION-VARIABLE" "WITH-LOCK-HELD" "CONDITION-WAIT" "DESTROY-THREAD" 
"CURRENT-THREAD") '#1#  '"(private) Thread utilities.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.RAW-QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL") (#2#  '#1# ) '#1#  '("RAW-QUEUE" "MAKE-RAW-QUEUE" 
"PUSH-RAW-QUEUE" "POP-RAW-QUEUE" "PEEK-RAW-QUEUE" "RAW-QUEUE-COUNT" "RAW-QUEUE-EMPTY-P") 
'#1#  '"(private) Raw queue data structure.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.CONS-QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.RAW-QUEUE") (#2#  
'#1# ) '#1#  '("CONS-QUEUE" "MAKE-CONS-QUEUE" "PUSH-CONS-QUEUE" "PUSH-CONS-QUEUE/NO-LOCK" 
"POP-CONS-QUEUE" "POP-CONS-QUEUE/NO-LOCK" "PEEK-CONS-QUEUE" "PEEK-CONS-QUEUE/NO-LOCK" 
"CONS-QUEUE-COUNT" "CONS-QUEUE-COUNT/NO-LOCK" "CONS-QUEUE-EMPTY-P" "CONS-QUEUE-EMPTY-P/NO-LOCK" 
"TRY-POP-CONS-QUEUE" "TRY-POP-CONS-QUEUE/NO-LOCK" "WITH-LOCKED-CONS-QUEUE") '#1#  
'"(private) Blocking infinite-capacity queue.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.VECTOR-QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL") (#2#  '#1# ) '#1#  '("VECTOR-QUEUE" 
"MAKE-VECTOR-QUEUE" "PUSH-VECTOR-QUEUE" "PUSH-VECTOR-QUEUE/NO-LOCK" "POP-VECTOR-QUEUE" 
"POP-VECTOR-QUEUE/NO-LOCK" "PEEK-VECTOR-QUEUE" "PEEK-VECTOR-QUEUE/NO-LOCK" "VECTOR-QUEUE-COUNT" 
"VECTOR-QUEUE-COUNT/NO-LOCK" "VECTOR-QUEUE-EMPTY-P" "VECTOR-QUEUE-EMPTY-P/NO-LOCK" 
"VECTOR-QUEUE-FULL-P" "VECTOR-QUEUE-FULL-P/NO-LOCK" "TRY-POP-VECTOR-QUEUE" "TRY-POP-VECTOR-QUEUE/NO-LOCK" 
"WITH-LOCKED-VECTOR-QUEUE" "VECTOR-QUEUE-CAPACITY") '#1#  '"(private) Blocking fixed-capacity queue.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.CONS-QUEUE" "LPARALLEL.VECTOR-QUEUE") 
(#2#  '#1# ) '#1#  '("QUEUE" "MAKE-QUEUE" "PUSH-QUEUE" "PUSH-QUEUE/NO-LOCK" "POP-QUEUE" 
"POP-QUEUE/NO-LOCK" "PEEK-QUEUE" "PEEK-QUEUE/NO-LOCK" "QUEUE-COUNT" "QUEUE-COUNT/NO-LOCK" 
"QUEUE-EMPTY-P" "QUEUE-EMPTY-P/NO-LOCK" "QUEUE-FULL-P" "QUEUE-FULL-P/NO-LOCK" "TRY-POP-QUEUE" 
"TRY-POP-QUEUE/NO-LOCK" "WITH-LOCKED-QUEUE") '#1#  '"Blocking FIFO queue for communication between threads.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.BIASED-QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.RAW-QUEUE") (#2#  
'#1# ) '#1#  '("BIASED-QUEUE" "MAKE-BIASED-QUEUE" "PUSH-BIASED-QUEUE" "PUSH-BIASED-QUEUE/NO-LOCK" 
"PUSH-BIASED-QUEUE/LOW" "PUSH-BIASED-QUEUE/LOW/NO-LOCK" "POP-BIASED-QUEUE" "POP-BIASED-QUEUE/NO-LOCK" 
"PEEK-BIASED-QUEUE" "PEEK-BIASED-QUEUE/NO-LOCK" "BIASED-QUEUE-EMPTY-P" "BIASED-QUEUE-EMPTY-P/NO-LOCK" 
"TRY-POP-BIASED-QUEUE" "TRY-POP-BIASED-QUEUE/NO-LOCK" "POP-BIASED-QUEUE" "POP-BIASED-QUEUE/NO-LOCK" 
"BIASED-QUEUE-COUNT" "BIASED-QUEUE-COUNT/NO-LOCK" "WITH-LOCKED-BIASED-QUEUE") '#1#  
'"(private) Blocking two-tiered priority queue.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.COUNTER" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL") (#2#  '#1# ) '#1#  '("COUNTER" 
"MAKE-COUNTER" "INC-COUNTER" "DEC-COUNTER" "COUNTER-VALUE") '#1#  '"(private) Atomic counter.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.SPIN-QUEUE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL") (#2#  '#1# ) '#1#  '("SPIN-QUEUE" 
"MAKE-SPIN-QUEUE" "PUSH-SPIN-QUEUE" "POP-SPIN-QUEUE" "PEEK-SPIN-QUEUE" "SPIN-QUEUE-COUNT" 
"SPIN-QUEUE-EMPTY-P") '#1#  '"(private) Thread-safe FIFO queue which spins instead of locks.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.KERNEL" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.QUEUE" "LPARALLEL.BIASED-QUEUE" 
"LPARALLEL.SPIN-QUEUE" "LPARALLEL.COUNTER") (#2#  '#1# ) '#1#  '("MAKE-KERNEL" "CHECK-KERNEL" 
"END-KERNEL" "KERNEL-WORKER-COUNT" "KERNEL-BINDINGS" "KERNEL-NAME" "KERNEL-CONTEXT" 
"MAKE-CHANNEL" "SUBMIT-TASK" "SUBMIT-TIMEOUT" "CANCEL-TIMEOUT" "RECEIVE-RESULT" "TRY-RECEIVE-RESULT" 
"DO-FAST-RECEIVES" "KILL-TASKS" "TASK-HANDLER-BIND" "TASK-CATEGORIES-RUNNING" "INVOKE-TRANSFER-ERROR" 
"*KERNEL*" "*KERNEL-SPIN-COUNT*" "*TASK-CATEGORY*" "*TASK-PRIORITY*" "*DEBUG-TASKS-P*" 
"KERNEL" "CHANNEL" "TRANSFER-ERROR" "NO-KERNEL-ERROR" "KERNEL-CREATION-ERROR" "TASK-KILLED-ERROR") 
'#1#  '"Encompasses the scheduling and execution of parallel tasks using a
   pool of worker threads. All parallelism in lparallel is done on top
   of the kernel.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.KERNEL-UTIL" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.KERNEL" "LPARALLEL.QUEUE" "LPARALLEL.COUNTER") 
(#2#  '#1# ) '#1#  '("WITH-SUBMIT-COUNTED" "SUBMIT-COUNTED" "RECEIVE-COUNTED" "WITH-SUBMIT-INDEXED" 
"SUBMIT-INDEXED" "RECEIVE-INDEXED" "WITH-SUBMIT-CANCELABLE" "SUBMIT-CANCELABLE" "RECEIVE-CANCELABLES") 
'#1#  '"(semi-private) Abstracts some common patterns for submitting and
   receiving tasks. This probably won't change, but no guarantees.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.PTREE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.KERNEL" "LPARALLEL.QUEUE") 
(#2#  '#1# ) '#1#  '("PTREE" "PTREE-FN" "MAKE-PTREE" "CHECK-PTREE" "CALL-PTREE" "PTREE-COMPUTED-P" 
"CLEAR-PTREE" "CLEAR-PTREE-ERRORS" "*PTREE-NODE-KERNEL*" "PTREE-UNDEFINED-FUNCTION-ERROR" 
"PTREE-LAMBDA-LIST-KEYWORD-ERROR" "PTREE-REDEFINITION-ERROR") '#1#  '"A ptree is a computation represented by a tree together with
   functionality to execute the tree in parallel.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.PROMISE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.THREAD-UTIL" "LPARALLEL.KERNEL") (#2#  
'#1# ) '#1#  '("PROMISE" "FUTURE" "SPECULATE" "DELAY" "FORCE" "FULFILL" "FULFILLEDP" 
"CHAIN") '#1#  '"Promises and futures.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.DEFPUN" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.KERNEL" "LPARALLEL.THREAD-UTIL") (#2#  
'#1# ) '#1#  '("DEFPUN" "DEFPUN*" "DEFPUN/TYPE" "DEFPUN/TYPE*" "DECLAIM-DEFPUN" "PLET" 
"PLET-IF") '#1#  '"Fine-grained parallelism.")
(SYSTEM::%DEFPACKAGE "LPARALLEL.COGNATE" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.UTIL" "LPARALLEL.KERNEL" "LPARALLEL.KERNEL-UTIL" "LPARALLEL.PROMISE" 
"LPARALLEL.DEFPUN") (#2#  '#1# ) '#1#  '("PAND" "PCOUNT" "PCOUNT-IF" "PCOUNT-IF-NOT" 
"PDOTIMES" "PEVERY" "PFIND" "PFIND-IF" "PFIND-IF-NOT" "PFUNCALL" "PLET" "PLET-IF" 
"PMAP" "PMAPC" "PMAPCAN" "PMAPCAR" "PMAPCON" "PMAP-INTO" "PMAPL" "PMAPLIST" "PMAPLIST-INTO" 
"PMAP-REDUCE" "PNOTANY" "PNOTEVERY" "POR" "PREDUCE" "PREDUCE-PARTIAL" "PREMOVE" "PREMOVE-IF" 
"PREMOVE-IF-NOT" "PSOME" "PSORT" "PSORT*") '#1#  '"Parallelized versions of some Common Lisp functions.")
(SYSTEM::%DEFPACKAGE "LPARALLEL" '#1=COMMON-LISP:NIL '#1#  '#1#  (#2=SYSTEM::ENSURE-AVAILABLE-SYMBOLS 
'#1# ) '("CL" "LPARALLEL.KERNEL" "LPARALLEL.PROMISE" "LPARALLEL.DEFPUN" "LPARALLEL.COGNATE" 
"LPARALLEL.PTREE") (#2#  '#1# ) '#1#  '("*DEBUG-TASKS-P*" "*TASK-PRIORITY*" "TASK-KILLED-ERROR" 
"KERNEL-BINDINGS" "NO-KERNEL-ERROR" "RECEIVE-RESULT" "KERNEL" "END-KERNEL" "CANCEL-TIMEOUT" 
"KERNEL-CREATION-ERROR" "*KERNEL-SPIN-COUNT*" "TRY-RECEIVE-RESULT" "SUBMIT-TASK" 
"KERNEL-WORKER-COUNT" "CHECK-KERNEL" "MAKE-CHANNEL" "DO-FAST-RECEIVES" "TASK-HANDLER-BIND" 
"*KERNEL*" "KERNEL-CONTEXT" "INVOKE-TRANSFER-ERROR" "TASK-CATEGORIES-RUNNING" "MAKE-KERNEL" 
"KERNEL-NAME" "CHANNEL" "*TASK-CATEGORY*" "SUBMIT-TIMEOUT" "KILL-TASKS" "TRANSFER-ERROR" 
"SPECULATE" "PROMISE" "FUTURE" "FULFILLEDP" "FULFILL" "CHAIN" "FORCE" "DELAY" "DEFPUN*" 
"DECLAIM-DEFPUN" #3="PLET-IF" "DEFPUN/TYPE" #4="PLET" "DEFPUN" "DEFPUN/TYPE*" "PFIND" 
"PAND" "PREMOVE" "PNOTANY" "PCOUNT" "PMAPLIST-INTO" "PSORT*" "PMAP" "PSOME" "PREMOVE-IF" 
#4#  "PCOUNT-IF" "PEVERY" "PMAP-INTO" "PMAPCAN" "PREMOVE-IF-NOT" "PMAPCAR" "PMAPLIST" 
"PREDUCE-PARTIAL" "PMAPC" "PSORT" "PFUNCALL" "PFIND-IF-NOT" "PMAPCON" #3#  "PMAPL" 
"PCOUNT-IF-NOT" "PNOTEVERY" "PFIND-IF" "POR" "PMAP-REDUCE" "PREDUCE" "PDOTIMES" "PTREE" 
"PTREE-REDEFINITION-ERROR" "*PTREE-NODE-KERNEL*" "PTREE-UNDEFINED-FUNCTION-ERROR" 
"PTREE-FN" "CHECK-PTREE" "CLEAR-PTREE-ERRORS" "PTREE-LAMBDA-LIST-KEYWORD-ERROR" "CLEAR-PTREE" 
"MAKE-PTREE" "CALL-PTREE" "PTREE-COMPUTED-P") '#1#  '"This is a convenience package which exports the external symbols of:
   lparallel.kernel
   lparallel.promise
   lparallel.defpun
   lparallel.cognate
   lparallel.ptree")
